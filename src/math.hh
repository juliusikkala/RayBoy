#ifndef RAYBOY_MATH_HH
#define RAYBOY_MATH_HH
#define GLM_ENABLE_EXPERIMENTAL
// Makes GLM angles predictable
#define GLM_FORCE_RADIANS
#define GLM_FORCE_INTRINSICS
#define GLM_FORCE_SSE2
#define GLM_FORCE_DEFAULT_ALIGNED_GENTYPES
#include <glm/glm.hpp>
#include <glm/gtc/constants.hpp>
#include <glm/gtx/transform.hpp>
#include <glm/gtx/quaternion.hpp>
#include <glm/gtx/dual_quaternion.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <glm/gtc/matrix_inverse.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/random.hpp>
#include <glm/gtx/matrix_decompose.hpp>
#include <glm/gtx/hash.hpp>
#include <glm/gtc/integer.hpp>
#include <string>
#include <vector>
#include <complex>

#if GLM_VERSION != 998
#pragma warning "This program was written to use GLM 0.9.9.9. " \
    GLM_VERSION_MESSAGE
#endif

// Because of our SSE forcing, the default vec2, vec3 and vec4 types are
// aligned to 4. Practically, this means that vec3 is too large. If for memory
// reasons packed vectors are desired, use the following types.
using pvec4 = glm::vec<4, float, glm::packed_highp>;
using pvec3 = glm::vec<3, float, glm::packed_highp>;
using pvec2 = glm::vec<2, float, glm::packed_highp>;
using pivec4 = glm::vec<4, int, glm::packed_highp>;
using pivec3 = glm::vec<3, int, glm::packed_highp>;
using pivec2 = glm::vec<2, int, glm::packed_highp>;
using puvec4 = glm::vec<4, unsigned, glm::packed_highp>;
using puvec3 = glm::vec<3, unsigned, glm::packed_highp>;
using puvec2 = glm::vec<2, unsigned, glm::packed_highp>;
using pmat4 = glm::mat<4, 4, float, glm::packed_highp>;
using pmat3 = glm::mat<3, 3, float, glm::packed_highp>;
using pmat2 = glm::mat<2, 2, float, glm::packed_highp>;

using namespace glm;

template<length_t L, typename T, glm::qualifier Q>
T vecmax(const vec<L, T, Q>& v);

template<length_t L, typename T, glm::qualifier Q>
T vecmin(const vec<L, T, Q>& v);

bool point_in_rect(vec2 p, vec2 o, vec2 sz);
bool point_in_triangle(vec2 a, vec2 b, vec2 c, vec2 p);
vec3 barycentric(vec2 a, vec2 b, vec2 c, vec2 p);
float signed_area(vec2 a, vec2 b, vec2 c);

vec3 hsv_to_rgb(vec3 hsv);
float circle_sequence(unsigned n);
vec3 generate_color(int32_t index, float saturation = 1.0f, float value = 1.0f);

// Doesn't work correctly with shearing.
void decompose_matrix(
    const mat4& transform,
    vec3& translation,
    vec3& scaling,
    quat& orientation
);

vec3 get_matrix_translation(const mat4& transform);
vec3 get_matrix_scaling(const mat4& transform);
quat get_matrix_orientation(const mat4& transform);

quat rotate_towards(
    quat orig,
    quat dest,
    float angle_limit
);

quat quat_lookat(
    vec3 dir,
    vec3 up,
    vec3 forward = vec3(0,0,-1)
);

bool solve_quadratic(float a, float b, float c, float& x0, float& x1);
void solve_cubic_roots(
    double a, double b, double c, double d,
    std::complex<double>& r1,
    std::complex<double>& r2,
    std::complex<double>& r3
);

double cubic_bezier(dvec2 p1, dvec2 p2, double t);
template<typename T>
T cubic_spline(T p1, T m1, T p2, T m2, float t);

bool intersect_sphere(
    vec3 pos,
    vec3 dir,
    vec3 origin,
    float radius,
    float& t0,
    float& t1
);

unsigned next_power_of_two(unsigned n);
unsigned factorize(unsigned n);

// Computes a modelview matrix for a quad such that it completely covers the
// surface area of a sphere. use_near_radius determines whether the resulting
// depth value is picked from the near edge of the sphere or the furthest edge.
mat4 sphere_projection_quad_matrix(
    vec3 pos,
    float r,
    float near,
    float far,
    bool use_near_radius = false,
    float big = 1e3
);

// Note that this function is very slow. Please save your generated samples.
// If samples already contain some values, they're assumed to be generated by
// a previous call to this function with the same r.
// Circular version
void mitchell_best_candidate(
    std::vector<vec2>& samples,
    float r,
    unsigned candidate_count,
    unsigned count
);

// Rectangular version
void mitchell_best_candidate(
    std::vector<vec2>& samples,
    float w,
    float h,
    unsigned candidate_count,
    unsigned count
);

// Spherical version
void mitchell_best_candidate(
    std::vector<vec3>& samples,
    float r,
    unsigned candidate_count,
    unsigned count
);

std::vector<vec2> grid_samples(
    unsigned w,
    unsigned h,
    float step
);

std::vector<float> generate_gaussian_kernel(
    int radius,
    float sigma
);

vec3 pitch_yaw_to_vec(float pitch, double yaw);

uvec2 string_to_resolution(const std::string& str);

unsigned calculate_mipmap_count(uvec2 size);

// axis-aligned bounding box
struct aabb
{
    vec3 min;
    vec3 max;
};

unsigned ravel_tex_coord(uvec3 p, uvec3 size);

struct ray
{
    vec3 o;
    vec3 dir;
};

ray operator*(const mat4& mat, const ray& r);

// This function simply checks if the given matrix causes the winding order
// of triangles in a model to flip.
bool flipped_winding_order(const mat3& transform);

#include "math.tcc"
#endif
